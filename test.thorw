require 'thor'

class Counter < Thor
  system('clear')
   
  ############################################

  desc 'set', 'This function autoset tasks'
  def set 
  has = Counter.tasks
  keys_tasks = [] # All methods name
  tmp_values_tasks = []

  has.each_key {|key| keys_tasks << key }
  has.each_value {|value| tmp_values_tasks << value }
  v_task = []

  tmp_values_tasks.each do |v|
    k = /n=\"(.*)\", l/i.match(v.to_s)
    v_task << k[1]
  end
  v_task = v_task.drop(2) # Delete first two el in array
  puts("[ Welcome to the ruby Math tasks ] \n\n")
  i=0
  v_task.map { |task| puts "       #{i += 1} <-- #{task}" }
  puts " "
  end

  ############################################

  desc "get_num", "Get num in list"
  def get_num    
    set
    name_task = Counter.tasks
    keys_tasks = []
    name_task.each_key {|key| keys_tasks << key }
    keys_tasks = keys_tasks.drop(2)
    n = ask("Number program what we need to USE?\n" \
        'Or write exit press ENTER', color="\e[32m")
    kt_length = keys_tasks.length
    test=(1..keys_tasks.length).to_a
       
      i=0
      while i < keys_tasks.length do
      case n.upcase
      when 'exit'.upcase
        system('clear')
      when test[i].to_s
        system('clear')
        send(keys_tasks[i])
      end
      i += 1
      end
 
  ############################################

      back_command = lambda { 
        back = ask("\nBack to list program write -B press ENTER " \
            "or write -Q press ENTER to exit\n", color = "\e[1m")

        if back.upcase == "-b".upcase
          system('clear')
          return get_num
        elsif back.upcase == "-q".upcase
          system('quit')
        else
          system('clear')
          say("Write correct number \n", color = "\e[31m")
          back_command.call
        end
      }
      back_command.call
  end

  ############################################

  desc "occurrence_number", "Finding number 3 in n^2 sequence"
  def occurrence_number # Finding number 3 in n^2 sequence
    n = ask("Enter number to squared", color = "\e[1m").to_i
    number_three = ask("Enter the search value", color = "\e[1m")
    num = (n**2).to_s # Convert to String
    n = (n**2).to_s.split('') # Divide string to array
    p number_three
    n = n.select { |i| i == number_three } # Select number_three in n - array
    if n.empty?
      puts num + " - This sequence has no number #{number_three}"
    else
      puts num + " - This sequence has number #{number_three}"
    end
  end

  desc "abramov_322", "Returns a MAX SUM DIVIDES numbers within all natural"
  def abramov_322
  puts 'Write last number of range'

  n = ask("Enter number", color = "\e[1m").to_i # Get user data
  numbers = (1..n).to_a   # Convert range to array

  arr = numbers.map do |number| # Create result array witch contains sum divedes
    a = (1..number).select { |value| (number % value).zero? && value != number }
    a.inject(0) { |sum, x| sum + x }
  end
  puts 'Max element in result array'
  p arr.inject { |m, x| m > x ? m : x } # Get max element in result array

  end

  desc "get_perfects_num", "Get All perfect numbers < n"
  def get_perfects_num # Get All perfect numbers < n
  puts 'Write the number to get all perfect numbers'
  n = ask("Enter number", color = "\e[1m").to_i
  numbers = (1..n).to_a # Convert range to array
  arr = numbers.map do |number| # Create result array witch contains sum divedes
    a = (1..number).select { |k| (number % k).zero? && k != number }
    a.inject(0) { |sum, x| sum + x }
  end
  result = []
  arr.each_with_index do |_, i|
    if numbers[i] == arr[i] then result << arr[i] end # Compare to value range 
  end
  puts result # Convert array to string
end

   
end

